======================================
 Release notes for Numexpr 1.4 series
======================================

Changes from 1.4.1 to 1.4.2
===========================

- Multithreaded operation is disabled for small arrays (< 32 KB).
  This allows to remove the overhead of multithreading for such a
  small arrays.  Closes #36.

- Dividing int arrays by zero gives a 0 as result now (and not a
  floating point exception anymore.  This behaviour mimics NumPy.
  Thanks to Gaëtan de Menten for the fix.  Closes #37.

- When compiled with VML support, the number of threads is set to 1
  for VML core, and to the number of cores for the native pthreads
  implementation.  This leads to much better performance.  Closes #39.

- Fixed different issues with reduction operations (`sum`, `prod`).
  The problem is that the threaded code does not work well for
  broadcasting or reduction operations.  Now, the serial code is used
  in those cases.  Closes #41.

- Optimization of "compilation phase" through a better hash.  This can
  lead up to a 25% of improvement when operating with variable
  expressions over small arrays.  Thanks to Gaëtan de Menten for the
  patch.  Closes #43.

- The ``set_num_threads`` now returns the number of previous thread
  setting, as stated in the docstrings.


Changes from 1.4 to 1.4.1
=========================

- Mingw32 can also work with pthreads compatibility code for win32.
  Fixes #31.

- Fixed a problem that used to happen when running Numexpr with
  threads in subprocesses.  It seems that threads needs to be
  initialized whenever a subprocess is created.  Fixes #33.

- The GIL (Global Interpreter Lock) is released during computations.
  This should allow for better resource usage for multithreaded apps.
  Fixes #35.


Changes from 1.3.1 to 1.4
=========================

- Added support for multi-threading in pure C.  This is to avoid the
  GIL and allows to squeeze the best performance in both multi-core
  machines.

- David Cooke contributed a thorough refactorization of the opcode
  machinery for the virtual machine.  With this, it is really easy to
  add more opcodes.  See:

  http://code.google.com/p/numexpr/issues/detail?id=28

  as an example.

- Added a couple of opcodes to VM: where_bbbb and cast_ib. The first
  allow to get boolean arrays out of the `where` function.  The second
  allows to cast a boolean array into an integer one.  Thanks to
  gdementen for his contribution.

- Fix negation of `int64` numbers. Closes #25.

- Using a `npy_intp` datatype (instead of plain `int`) so as to be
  able to manage arrays larger than 2 GB.


Changes from 1.3 to 1.3.1
=========================

- Due to an oversight, ``uint32`` types were not properly supported.
  That has been solved.  Fixes #19.

- Function `abs` for computing the absolute value added.  However, it
  does not strictly follow NumPy conventions.  See ``README.txt`` or
  website docs for more info on this.  Thanks to Pauli Virtanen for
  the patch.  Fixes #20.


Changes from 1.2 to 1.3
=======================

- A new type called internally `float` has been implemented so as to
  be able to work natively with single-precision floating points.
  This prevents the silent upcast to `double` types that was taking
  place in previous versions, so allowing both an improved performance
  and an optimal usage of memory for the single-precision
  computations.  However, the casting rules for floating point types
  slightly differs from those of NumPy.  See:

      http://code.google.com/p/numexpr/wiki/Overview

  or the README.txt file for more info on this issue.

- Support for Python 2.6 added.

- When linking with the MKL, added a '-rpath' option to the link step
  so that the paths to MKL libraries are automatically included into
  the runtime library search path of the final package (i.e. the user
  won't need to update its LD_LIBRARY_PATH or LD_RUN_PATH environment
  variables anymore).  Fixes #16.


Changes from 1.1.1 to 1.2
=========================

- Support for Intel's VML (Vector Math Library) added, normally
  included in Intel's MKL (Math Kernel Library).  In addition, when
  the VML support is on, several processors can be used in parallel
  (see the new `set_vml_num_threads()` function).  With that, the
  computations of transcendental functions can be accelerated quite a
  few.  For example, typical speed-ups when using one single core for
  contiguous arrays are 3x with peaks of 7.5x (for the pow() function).
  When using 2 cores the speed-ups are around 4x and 14x respectively.
  Closes #9.

- Some new VML-related functions have been added:

  * set_vml_accuracy_mode(mode):  Set the accuracy for VML operations.

  * set_vml_num_threads(nthreads): Suggests a maximum number of
    threads to be used in VML operations.

  * get_vml_version():  Get the VML/MKL library version.

  See the README.txt for more info about them.

- In order to easily allow the detection of the MKL, the setup.py has
  been updated to use the numpy.distutils.  So, if you are already
  used to link NumPy/SciPy with MKL, then you will find that giving
  VML support to numexpr works almost the same.

- A new `print_versions()` function has been made available.  This
  allows to quickly print the versions on which numexpr is based on.
  Very handy for issue reporting purposes.

- The `numexpr.numexpr` compiler function has been renamed to
  `numexpr.NumExpr` in order to avoid name collisions with the name of
  the package (!).  This function is mainly for internal use, so you
  should not need to upgrade your existing numexpr scripts.


Changes from 1.1 to 1.1.1
=========================

- The case for multidimensional array operands is properly accelerated
  now.  Added a new benchmark (based on a script provided by Andrew
  Collette, thanks!) for easily testing this case in the future.
  Closes #12.

- Added a fix to avoid the caches in numexpr to grow too much.  The
  dictionary caches are kept now always with less than 256 entries.
  Closes #11.

- The VERSION file is correctly copied now (it was not present for the
  1.1 tar file, I don't know exactly why).  Closes #8.


Changes from 1.0 to 1.1
=======================

- Numexpr can work now in threaded environments.  Fixes #2.

- The test suite can be run programmatically by using
  ``numexpr.test()``.

- Support a more complete set of functions for expressions (including
  those that are not supported by MSVC 7.1 compiler, like the inverse
  hyperbolic or log1p and expm1 functions.  The complete list now is:

    * where(bool, number1, number2): number
        Number1 if the bool condition is true, number2 otherwise.
    * {sin,cos,tan}(float|complex): float|complex
        Trigonometric sinus, cosinus or tangent.
    * {arcsin,arccos,arctan}(float|complex): float|complex
        Trigonometric inverse sinus, cosinus or tangent.
    * arctan2(float1, float2): float
        Trigonometric inverse tangent of float1/float2.
    * {sinh,cosh,tanh}(float|complex): float|complex
        Hyperbolic sinus, cosinus or tangent.
    * {arcsinh,arccosh,arctanh}(float|complex): float|complex
        Hyperbolic inverse sinus, cosinus or tangent.
    * {log,log10,log1p}(float|complex): float|complex
        Natural, base-10 and log(1+x) logarithms.
    * {exp,expm1}(float|complex): float|complex
        Exponential and exponential minus one.
    * sqrt(float|complex): float|complex
        Square root.
    * {real,imag}(complex): float
        Real or imaginary part of complex.
    * complex(float, float): complex
        Complex from real and imaginary parts.



.. Local Variables:
.. mode: rst
.. coding: utf-8
.. fill-column: 70
.. End:
